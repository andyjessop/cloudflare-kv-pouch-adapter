File: packages/logger/package.json

{
	"name": "logger",
	"type": "module",
	"main": "src/index.ts"
}


File: packages/logger/src/logger.ts

export interface Logger {
	success(message: string, ...args: unknown[]): void;
	info(message: string, ...args: unknown[]): void;
	warn(message: string, ...args: unknown[]): void;
	error(message: string, ...args: unknown[]): void;
}

export const logger = { error, info, success, warn };

function success(message: string, ...args: unknown[]): void {
	console.log(`\x1b[32m[${getTimestamp()}] ✔ ${message}\x1b[0m`, ...args);
}

function info(message: string, ...args: unknown[]): void {
	console.log(`\x1b[36m[${getTimestamp()}] ℹ ${message}\x1b[0m`, ...args);
}

function warn(message: string, ...args: unknown[]): void {
	console.warn(`\x1b[33m[${getTimestamp()}] ⚠ ${message}\x1b[0m`, ...args);
}

function error(message: string, ...args: unknown[]): void {
	console.error(`\x1b[31m[${getTimestamp()}] ✖ ${message}\x1b[0m`, ...args);
}

function getTimestamp(): string {
	return new Date().toISOString();
}


File: packages/async-map/package.json

{
	"name": "async-map"
}


File: packages/async-map/src/types.ts

export interface AsyncMap<K, V> {
	/**
	 * Removes all entries from the map.
	 * @returns A promise that resolves when the operation is complete.
	 */
	clear(): Promise<void>;

	/**
	 * Removes the specified key from the map.
	 * @param key The key to delete.
	 * @returns A promise that resolves to a boolean indicating whether the key existed and was deleted.
	 */
	delete(key: K): Promise<boolean>;

	/**
	 * Executes a provided function once for each key-value pair in the map, in insertion order.
	 * @param callbackFn A function that is called for each entry in the map.
	 * @param thisArg Optional. A value to use as `this` when executing the callback.
	 * @returns A promise that resolves when the iteration is complete.
	 */
	forEach(
		callbackFn: (value: V, key: K, map: AsyncMap<K, V>) => void | Promise<void>,
		thisArg?: any,
	): Promise<void>;

	/**
	 * Gets the value associated with the specified key.
	 * @param key The key to retrieve.
	 * @returns A promise that resolves to the value associated with the key, or undefined if the key does not exist.
	 */
	get(key: K): Promise<V | undefined>;

	/**
	 * Checks if the specified key exists in the map.
	 * @param key The key to check.
	 * @returns A promise that resolves to a boolean indicating whether the key exists.
	 */
	has(key: K): Promise<boolean>;

	/**
	 * Sets a key-value pair in the map.
	 * @param key The key to set.
	 * @param value The value to associate with the key.
	 * @returns A promise that resolves to undefined.
	 */
	set(key: K, value: V): Promise<void>;

	/**
	 * Retrieves the number of key-value pairs in the map.
	 * @returns A promise that resolves to the size of the map.
	 */
	size(): Promise<number>;
}


File: packages/kv-pouch/.dev.vars

SUPABASE_JWT_SECRET=7GCUYpfoLd0/g3flw1sJYmVkDXiHXZniTuaXKMi9tmUr1hJe9dK50d489ys3CNQK3+2B/Mg0iNlSloVXuWiL5w==


File: packages/kv-pouch/.gitignore

# Logs

logs
_.log
npm-debug.log_
yarn-debug.log*
yarn-error.log*
lerna-debug.log*
.pnpm-debug.log*

# Diagnostic reports (https://nodejs.org/api/report.html)

report.[0-9]_.[0-9]_.[0-9]_.[0-9]_.json

# Runtime data

pids
_.pid
_.seed
\*.pid.lock

# Directory for instrumented libs generated by jscoverage/JSCover

lib-cov

# Coverage directory used by tools like istanbul

coverage
\*.lcov

# nyc test coverage

.nyc_output

# Grunt intermediate storage (https://gruntjs.com/creating-plugins#storing-task-files)

.grunt

# Bower dependency directory (https://bower.io/)

bower_components

# node-waf configuration

.lock-wscript

# Compiled binary addons (https://nodejs.org/api/addons.html)

build/Release

# Dependency directories

node_modules/
jspm_packages/

# Snowpack dependency directory (https://snowpack.dev/)

web_modules/

# TypeScript cache

\*.tsbuildinfo

# Optional npm cache directory

.npm

# Optional eslint cache

.eslintcache

# Optional stylelint cache

.stylelintcache

# Microbundle cache

.rpt2_cache/
.rts2_cache_cjs/
.rts2_cache_es/
.rts2_cache_umd/

# Optional REPL history

.node_repl_history

# Output of 'npm pack'

\*.tgz

# Yarn Integrity file

.yarn-integrity

# dotenv environment variable files

.env
.env.development.local
.env.test.local
.env.production.local
.env.local

# parcel-bundler cache (https://parceljs.org/)

.cache
.parcel-cache

# Next.js build output

.next
out

# Nuxt.js build / generate output

.nuxt
dist

# Gatsby files

.cache/

# Comment in the public line in if your project uses Gatsby and not Next.js

# https://nextjs.org/blog/next-9-1#public-directory-support

# public

# vuepress build output

.vuepress/dist

# vuepress v2.x temp and cache directory

.temp
.cache

# Docusaurus cache and generated files

.docusaurus

# Serverless directories

.serverless/

# FuseBox cache

.fusebox/

# DynamoDB Local files

.dynamodb/

# TernJS port file

.tern-port

# Stores VSCode versions used for testing VSCode extensions

.vscode-test

# yarn v2

.yarn/cache
.yarn/unplugged
.yarn/build-state.yml
.yarn/install-state.gz
.pnp.\*

# wrangler project

.dev.vars
.wrangler/


File: packages/kv-pouch/package.json

{
	"name": "kv-pouch"
}

File: packages/kv-pouch/.env

CLOUDFLARE_ACCOUNT_ID=f7cbdb419b792e6ca5d4b0ed0c1d70e2
CLOUDFLARE_API_TOKEN=JUYR4bMK8n-vIjvUfIv6eguRGeSUTnokhyah6Hwy
CLOUDFLARE_EMAIL=andrewdjessop@protonmail.com
SUPABASE_DB_PASSWORD=we02909ewoidlksdj02oelakjslkjqwdlk
SUPABASE_JWT_SECRET=7GCUYpfoLd0/g3flw1sJYmVkDXiHXZniTuaXKMi9tmUr1hJe9dK50d489ys3CNQK3+2B/Mg0iNlSloVXuWiL5w==


File: packages/kv-pouch/src/KVLevel.ts

import type { AsyncMap } from "async-map/src/types.ts";

export class KVLevel<Env = unknown> implements AsyncMap<string, unknown> {
	kvNamespace: KVNamespace;
	env: Env;

	constructor(kvNamespace: KVNamespace, env: Env) {
		this.kvNamespace = kvNamespace;
		this.env = env;
	}

	/**
	 * Removes all entries from the map.
	 */
	async clear(): Promise<void> {
		const keys = await this.kvNamespace.list();
		for (const { name } of keys.keys) {
			await this.kvNamespace.delete(name);
		}
		return;
	}

	/**
	 * Removes the specified key from the map.
	 * @param key The key to delete.
	 * @returns A promise that resolves to a boolean indicating whether the key existed and was deleted.
	 */
	async delete(key: string): Promise<boolean> {
		const exists = await this.has(key);
		if (exists) {
			await this.kvNamespace.delete(key);
		}
		return exists;
	}

	/**
	 * Executes a provided function once for each key-value pair in the map, in insertion order.
	 * @param callbackfn A function that is called for each entry in the map.
	 * @param thisArg Optional. A value to use as `this` when executing the callback.
	 */
	async forEach(
		callbackfn: (
			value: unknown,
			key: string,
			map: AsyncMap<string, unknown>,
		) => void | Promise<void>,
		thisArg?: any,
	): Promise<void> {
		const entries = await this.kvNamespace.list();
		for (const { name: key } of entries.keys) {
			const value = await this.kvNamespace.get(key);
			await callbackfn.call(thisArg, value, key, this);
		}
	}

	/**
	 * Gets the value associated with the specified key.
	 * @param key The key to retrieve.
	 * @returns A promise that resolves to the value associated with the key, or undefined if the key does not exist.
	 */
	async get(key: string): Promise<unknown> {
		return this.kvNamespace.get(key);
	}

	/**
	 * Checks if the specified key exists in the map.
	 * @param key The key to check.
	 * @returns A promise that resolves to a boolean indicating whether the key exists.
	 */
	async has(key: string): Promise<boolean> {
		const value = await this.kvNamespace.get(key);
		return value !== null;
	}

	/**
	 * Sets a key-value pair in the map.
	 * @param key The key to set.
	 * @param value The value to associate with the key.
	 * @returns A promise that resolves to the instance of the map.
	 */
	async set(key: string, value: string): Promise<void> {
		await this.kvNamespace.put(key, value);
		return;
	}

	/**
	 * Retrieves the number of key-value pairs in the map.
	 * @returns A promise that resolves to the size of the map.
	 */
	async size(): Promise<number> {
		const entries = await this.kvNamespace.list();
		return entries.keys.length;
	}
}


File: packages/kv-pouch/src/kv-pouch.ts

import type { AsyncMap } from "async-map/src/types.ts";
import CoreLevelPouch from "pouchdb-adapter-leveldb-core";
import { AsyncMapLevel } from "./AsyncMapLevel.ts";

export function createKvPouch(stub: AsyncMap<string, string>) {
	KVPouch.valid = () => true;
	KVPouch.use_prefix = false;

	function KVPouch(opts: any, callback: any) {
		const _opts = Object.assign(
			{
				db: (location: string) => {
					return new AsyncMapLevel(stub, location);
				},
			},
			opts,
		);

		// @ts-ignore
		CoreLevelPouch.call(this, _opts, callback);
	}

	return KVPouch;
}


File: packages/kv-pouch/src/AsyncMapLevel.ts

import { AbstractLevelDOWN } from "abstract-leveldown";
import { AsyncMap } from "async-map/src/types";

type Callback<T = void> = (error?: Error | null, result?: T) => void;

export class AsyncMapLevel extends AbstractLevelDOWN<string, string> {
	#storage: AsyncMap<string, string>;

	constructor(storage: AsyncMap<string, string>, location?: string) {
		super(typeof location === "string" ? location : "");

		this.#storage = storage;
	}

	protected _serializeKey(key: string | Buffer): string {
		// If you want pure pass-through, treat Buffers as UTF-8 or otherwise
		// handle them. For plain strings, simply return the string itself.
		return key.toString();
	}

	protected _serializeValue(value: string | Buffer): string {
		return value.toString();
	}

	_info(callback: Callback<any>): void {
		Promise.resolve().then(() => callback(null, { type: "async-map" }));
	}

	_open(_: any, callback: Callback<this>): void {
		Promise.resolve().then(() => callback(null, this));
	}

	_put(key: string, value: string, _: any, callback: Callback): void {
		this.#storage.set(key, value).then(() => callback());
	}

	_get(key: string, _: any, callback: Callback<string | Buffer>): void {
		this.#storage.get(key).then((value) => {
			if (value === undefined) {
				callback(new Error("NotFound"));
			} else {
				callback(null, value);
			}
		});
	}

	_del(key: string, _: any, callback: Callback): void {
		this.#storage.delete(key).then(() => callback());
	}

	_batch(
		array: Array<{ key: string; value?: string; type: "put" | "del" }>,
		_: any,
		callback: Callback,
	): void {
		const promises = [];
		for (const operation of array) {
			if (!operation) continue;
			const { key, value, type } = operation;
			if (type === "put" && value !== undefined) {
				promises.push(this.#storage.set(key, value));
			} else if (type === "del") {
				promises.push(this.#storage.delete(key));
			}
		}
		Promise.all(promises).then(() => callback());
	}

	static destroy(_: string, callback: Callback): void {
		Promise.resolve().then(() => callback());
	}
}


File: packages/kv-pouch/src/index.ts

export { createKvPouch } from './kv-pouch'

File: packages/kv-pouch/src/CloudflareKVLevel.ts

import type { AsyncMap } from "async-map/src/types";

export class CloudflareKVMap<K, V> implements AsyncMap<K, V> {
	private kvNamespace: KVNamespace;

	constructor(kvNamespace: KVNamespace) {
		this.kvNamespace = kvNamespace;
	}

	async clear(): Promise<void> {
		const keys = await this.kvNamespace.list();
		for (const key of keys.keys) {
			await this.kvNamespace.delete(key.name);
		}
	}

	async delete(key: K): Promise<boolean> {
		const keyString = String(key); // Ensure the key is a string (Cloudflare KV requires string keys)
		const value = await this.kvNamespace.get(keyString);
		if (value === null) {
			return false; // Key doesn't exist
		}
		await this.kvNamespace.delete(keyString);
		return true;
	}

	async forEach(
		callbackFn: (value: V, key: K, map: AsyncMap<K, V>) => void | Promise<void>,
		thisArg?: any,
	): Promise<void> {
		const keys = await this.kvNamespace.list();
		for (const key of keys.keys) {
			const value = await this.kvNamespace.get(key.name);
			if (value !== null) {
				await callbackFn.call(thisArg, value as V, key.name as K, this);
			}
		}
	}

	async get(key: K): Promise<V | undefined> {
		const keyString = String(key); // Ensure the key is a string
		const value = await this.kvNamespace.get(keyString);
		return value ? (value as V) : undefined;
	}

	async has(key: K): Promise<boolean> {
		const keyString = String(key); // Ensure the key is a string
		const value = await this.kvNamespace.get(keyString);
		return value !== null;
	}

	async set(key: K, value: V): Promise<void> {
		const keyString = String(key); // Ensure the key is a string
		// @ts-ignore
		await this.kvNamespace.put(keyString, value);
	}

	async size(): Promise<number> {
		const keys = await this.kvNamespace.list();
		return keys.keys.length;
	}
}


